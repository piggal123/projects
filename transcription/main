import os

import guiClass
import threading
from tkinter.ttk import Progressbar
import tkinter as tk

from tkinter import Checkbutton, IntVar

from concurrent.futures import ThreadPoolExecutor
import pandas as pd

import requests
import base64
import warnings
import time
import speechboard_api
from speechboard_api.api import task_api

import tkinter.filedialog

from speechboard_api.model.recognize_task_request import RecognizeTaskRequest

from speechboard_api.model.batch_recognition_config import BatchRecognitionConfig

# creating a instance from the class to access the methods
gui_vars=guiClassN.gui_vars()
# creating the window
window = tk.Tk()
window.title("רשות התחרות")
window.geometry('420x350')

no_thread_check_box = IntVar()
no_download_check_box=IntVar()





# updating the data base, if it failed, saving the error
# in a local excel to track it later
def update_relativity():
	# sending a request to the server to update
  # the relevant fields 
  if j.ok:
      return True
  else:

      # updating the excel to show the text failed to be uploaded
      gui_vars.saving_excel(artifact_id,"failed to upload")
      print("ERROR:", artifact_id)
      return False
 


# setting the thread
class myThread (threading.Thread):
    def __init__(self, name,window, top_info_label,top_progress_bar,top_start_label,top_end_label,
     case_id_error_label,folder_error_label):
      threading.Thread.__init__(self)
      self.name = name
      self.window = window
      self.top_info_label= top_info_label
      self.top_progress_bar=top_progress_bar
      self.top_start_label=top_start_label
      self.top_end_label=top_end_label
      
      self.case_id_error_label=case_id_error_label
      
      self.folder_error_label=folder_error_label

    def run(self):
        if self.name=="checker":
            checker(self.window,self.top_info_label,self.top_progress_bar,self.top_start_label,self.top_end_label,
             self.case_id_error_label,self.folder_error_label)
       

# the method receives tk inter variables and updates them. the function will then
# call the text_extractor function to start the extraction from them records.


def files_iteration(window, top_info_label,top_progress_bar,top_start_label,top_end_label):


    files=os.listdir(gui_vars.get_dir_load())
    top_start_label.config(text="0")
    top_progress_bar['value']=0

    top_end_label.config(text=str(len(files)))
    top_progress_bar['maximum']=(len(files))
    # checking if the user checked the box for no threads 
    if (no_thread_check_box.get()==1):

 
        text_extractor(window,top_info_label,top_progress_bar,top_start_label,files)
      
    # the user wants threads    
    else:
        threads = []

        # calling the threadpoolexecutor to create threads by the number that the
        # user decided on. 
        with ThreadPoolExecutor(max_workers=gui_vars.get_workers()) as executor:
            # splitting the list into even parts, so each thread will run the same
            # amount of files
 
            for temp_list in [files[i::gui_vars.get_workers()] for i in range(gui_vars.get_workers())]:
                
                threads.append(executor.submit(text_extractor, window,top_info_label,top_progress_bar,top_start_label,temp_list))
                # making the thread wait 2 seconds so the system have time to process 
                time.sleep(2)
        
        
    # checking if the excel is empty   
    gui_vars.empty_excel()

    # updating the text label above the progress bar 
    top_info_label.config(text="done")    
    print("done")   
    et=time.time()
    print("took",round(et-gui_vars.get_st_time()),"seconds")

# extracting the file name with it's extenstion from the data
# returning the file name
def make_file_name(file_data):
    fields = file_data['FieldValues']
    
    # iterating through the file data 
    for field in fields:
        if field['Field']['Name'] == field name:
            extension = field['Value']
        elif field['Field']['Name'] == field name:
            name = field['Value']
    return name + "." + extension

# downloading the files from relativity, updating the tk inter variables 
def info_download(window,top_info_label,top_progress_bar
                                                                           ,top_start_label,top_end_label,
                                                                           resp):

    top_info_label.config(text="in progress")
    all_objects = resp['Objects']
    
    top_start_label.config(text="0")
    top_end_label.config(text=str(len(all_objects)))
    top_progress_bar['maximum']=len(all_objects)
    top_info_label.config(text="getting info")
    
    id_list=[]
    object_id_list=[]
    
    # iterating through the objects 
    for i in range(len(all_objects)):
        try:
            _object = all_objects[i]      
            id_list.append(_object['ArtifactID'])
            object_id_list.append(make_file_name(_object))
        except:
            if update_relativity(_object['ArtifactID'], "failed to save"):
                print("failed to save")
            gui_vars.saving_excel("file number"+str(_object['ArtifactID']),"failed to save")
        top_start_label.config(text=str(i))   
        top_progress_bar['value']=i    
        
    top_info_label.config(text="downloading files")

    top_start_label.config(text=("0"))   
    top_progress_bar['value']=0    
    print("Downloading files from Relativity...")
    

    if no_thread_check_box.get()==0:
        threads = []

        # calling the threadpoolexecutor to create threads by the number that the
        # user decided on. 
        with ThreadPoolExecutor(max_workers=gui_vars.get_workers()) as executor:
            # splitting the list into even parts, so each thread will run the same
            # amount of files
            k = 0
            splitted_id_list= [object_id_list[j::gui_vars.get_workers()] for j in range(gui_vars.get_workers())]

            for temp_list in [id_list[i::gui_vars.get_workers()] for i in range(gui_vars.get_workers())]:
                threads.append(executor.submit(files_download,window,top_info_label,top_progress_bar
                                                                                           ,top_start_label,top_end_label,
                                                                                           temp_list,splitted_id_list[k]))
                k+=1
                # making the thread wait 2 seconds so the system have time to process 
                time.sleep(2)
    else:

        files_download(window,top_info_label,top_progress_bar
                                                                                       ,top_start_label,top_end_label,id_list,object_id_list)
            
        
    print('finished downloading files from Relativity')        
    
# downloading the files from relativity, updating the tk inter variables 
def files_download(window,top_info_label,top_progress_bar
                                                                           ,top_start_label,top_end_label,
                                                                            id_list,object_id_list):

    for i in range(len(id_list)):
        response = requests.get(url =
            'https://relativity-web/Relativity.Rest/API/Relativity.Document/workspace/'+gui_vars.get_workspace_id()+'/downloadnativefile/'+str(id_list[i]),
            headers = head, verify = False)

        file = open(gui_vars.get_dir_load()+str(id_list[i])+'$'+object_id_list[i],"wb")
        file.write(response.content)
        file.close()


  
        file_path=gui_vars.get_dir_load()+str(id_list[i])+'$'+object_id_list[i]
        
        text_extractor(window, top_info_label, top_progress_bar, top_start_label,file_path)


def splitter(row):
    # seperating the word from the string 
    word=str(row["b"]).split(",")[3].split("'")
    
    return word[3]+" "

# the function gets the tk inter variables to update them.
# files: a list of files the function receives, then iterates over them to
# extract the text out of it.

def text_extractor(window,top_info_label,top_progress_bar,top_start_label,file_path):
  
    f= os.path.basename(file_path)
    tamlil_name = f.split("$")[0]


    print("file name is",file_path)
    bit_version = open(file_path, 'rb') 

    # server IP
    configuration = speechboard_api.Configuration(
        host =  Server-IP
    )
    
    # API key
    configuration.api_key['api_key'] = 
    try:
        with speechboard_api.ApiClient(configuration) as api_client:
            # Create an instance of the API class

            api_instance = task_api.TaskApi(api_client)

            artifact_id=tamlil_name.split(".")[0]
            # settings for the request 
            # preset= which moudle will be used for the text
. 
            request = RecognizeTaskRequest(
                config=BatchRecognitionConfig(
                    preset="telephony-general",  # TODO: Choose 'general', 'telephony'
                ),
            )
        

            top_info_label.config(text=tamlil_name+" in progress")
            text= " "

            try:
                # Create new task
                api_response = api_instance.create_task(request=request, file=bit_version)
                success_marker = True
                # saving the id of the response
                id = api_response.response.id
                
                
                st = time.time()
                accpeted= 0
		# waiting for the status of the request to change to finished
		# to extract the test from the repsonse 
                while (str(api_instance.get_task_by_id(id)["response"]["status"])!= "FINISHED"):
                    timlul_status = str(api_instance.get_task_by_id(id)["response"]["status"])

                    if timlul_status== "ACCEPTED":
                        accpeted = time.time()
                        formated_time="{:.2f}".format(accpeted-st)    
                        print(tamlil_name,"accepted for",formated_time, "seconds")
                        time.sleep(3)
                
                    elif timlul_status == "IN_PROGRESS":
                        et = time.time()
                        formated_time="{:.2f}".format(et-accpeted)  
                        print(tamlil_name,"in progress for",formated_time, "seconds")
                        time.sleep(3)
		
		    # checking if the system failed to read the file
	            # usually means the file is corrupted 
                    elif timlul_status == "ERROR_EXPIRED":
                        success_marker = False
                        text = "corrupted file"
                        print(tamlil_name,text)
                        if update_relativity(artifact_id,text):
                            print("file {} was succesfully uploaded to Relativity".format(f)) 

			# saving the error to a local excel as well
                        gui_vars.saving_excel(file_path,text)
                        break
               
                # making sure we are not coming from break statement before     
                if success_marker == True:
                    
                   # iterating through the words and speaker tags to create a text with new lines for each talker
                        try: 
                            
                            top_info_label.config(text="generating text for "+ tamlil_name)
                            print("generating text for",tamlil_name)
			    
		            # converting the repsonse to a data frame to easily manipulate it 
                            words_df = pd.DataFrame(api_instance.get_task_by_id(id)["response"]["response"]["results"][0]['nbests'][0]["words"])
                            
                            
                            words_df.columns=["words"]

                            words_df["words"]=words_df.apply(splitter,axis=1)
                            text= words_df["words"].sum()

                            # updating relativity object with the extracted text
                            if update_relativity(artifact_id,text):
                                print("file {} was succesfully uploaded to Relativity".format(f)) 

                            
                            
                    # the system failed to extract text from the record
                        except:
                           
                            text= "no sound"
                            # updating relativity object with the error text 

                            if update_relativity(artifact_id,text):
                                print("file {} error was succesfully uploaded to Relativity".format(f)) 

      
                            gui_vars.saving_excel(file_path, text)
                            print("file" ,f +text)
                            
                    
                
            
            # the api encountered an error
            except speechboard_api.ApiException as e:
		text = "problem with timlul"
                # updating relativity object with the error text 
                if update_relativity(artifact_id,text ):
                    print("file {} was succesfully uploaded to Relativity".format(f))
 
                gui_vars.saving_excel(file_path, text )
                print("Exception when calling TaskApi->create_task: %s\n" % e)
    except:
        text="problem with api"
        if update_relativity(artifact_id,text):
            print("file {} was succesfully uploaded to Relativity".format(f)) 

        gui_vars.saving_excel(file_path, text)

    # updating how many files finished
    gui_vars.increase_files_count()

    # updating the left label of the progress bar
    top_start_label.config(text=str(gui_vars.get_files_count()))

    # updating the progress bar value
    top_progress_bar['value']=gui_vars.get_files_count()

    # deleting the file locally so save space
    os.remove(file_path)
                

# recreating the folders to clear the data inside
def create_folder(folder):
    # checking if the folder exists
    if not os.path.exists(folder):
        os.makedirs(folder)

def start(window,top_info_label,top_progress_bar
                                                                           ,top_start_label,top_end_label,
                                                                            case_id_error_label
                                                                           ,folder_error_label):
    
    #gui_vars.reset_all()
    checker_thread = myThread("checker",window,top_info_label,top_progress_bar
                                                                               ,top_start_label,top_end_label,
                                                                                case_id_error_label,folder_error_label)
    
    checker_thread.start()

# the function receives the tkinter variables, updating them through the process
# the function will call the files_download thread to start downloading the files
def checker(window, top_info_label,top_progress_bar,top_start_label,top_end_label,case_id_error_label,folder_error_label):
    
    if gui_vars.get_dir_load()=="":
        folder_error_label.config(text="CHOOSE A FOLDER",fg="red")
    else:    
        folder_error_label.config(text="V")

        gui_vars.set_error_path("errors//")
        global thread_entry
        global e1
     

        try:
            # checking if the user put a number in the entry
            gui_vars.set_workers(int(thread_entry.get()))
            
            # limiting the amount of threads to 15, even if the user
            # input more (system limit)
            if (gui_vars.get_workers()>15):
                gui_vars.set_workers(15)
            
            # if the user input 0, making sure the program will
            # still run
            if(gui_vars.get_workers()<1):
                gui_vars.set_workers(1)
        
        # the user ignored the entry, setting the threads number to 15
        # (as stated in the gui, 15 is the default)            
        except:
            gui_vars.set_workers(15)
        
        workspace_id=e1.get()

        if(workspace_id==""):
            case_id_error_label.config(text="ENTER CASE ID", fg ="red")
            print("please enter workspace ID")
            
        else:
            case_id_error_label.config(text="V", fg="green")
            gui_vars.set_workspace_id(str(workspace_id))
            warnings.catch_warnings()
            warnings.simplefilter("ignore")
    

   
            create_folder(gui_vars.get_dir_load())

            create_folder(gui_vars.get_error_path())
            # creating a request for the server
            request_body={
               "Request":{
                "ObjectType": {
                "ArtifactTypeID": number
                    },
                    "fields": [
                    {"Name": field name},
                    {"Name" : field name},
                    ],
                    "condition" :conidition
                    "sorts":[
                    ]
                },
                "start" : 0,
                "length" : 50000
            }
            top_info_label.config(text="in progress")    
            response = requests.post(url =)
            resp = response.json()
            
            info_download(window,top_info_label,top_progress_bar
                                                                                       ,top_start_label,top_end_label,
                                                                                       resp)
        
#getting the folder path from the user
def get_folder_path(window,folder_error_label):
    
    gui_vars.set_dir_load(tk.filedialog.askdirectory())
    # updating the gui to show if the user chose a folder

    if(gui_vars.get_dir_load()==""):
        # the user didn't choose a folder, letting him know by putting an
        # 'x' next to the button
        folder_error_label.config(text="X",fg="red")
    else:
    
        folder_error_label.config(text="V",fg="green")
        
#defining the gui 
def gui_configurtion():
    # setting the font for the tittle
    Font_tuple = ("Comic Sans MS", 20, "bold")
    font_text= (14)
    
    
    title = tk.Label(text="Timlul")
    title.configure(font = Font_tuple)
    title.grid(row=0,column = 2)
    
    label_one = tk.Label(text="choose a folder to load from",font=font_text)
    label_one.grid(row=1, column = 2)
    

    label_two = tk.Label(text="then press start",font=font_text)
    label_two.grid(row=2, column = 2)
    
    tk.Label(window,text="CaseID", font=font_text).place(x=50,y=90)
    
    case_id_error_label=tk.Label(window,text="",font=font_text)
    case_id_error_label.place(x=280,y=90)
    global e1
    e1 = tk.Entry(window)
    e1.grid(row=3, column=2)
    
    top_info_label = tk.Label(text= "",font=font_text, width=42)
    top_info_label.grid(row=4,column = 2)
    
    top_start_label = tk.Label(text="", font=font_text)
    top_start_label.place(x=75,y = 133)
    
    top_progress_bar = Progressbar(window, orient= 'HORIZONTAL'.lower(),length= 100, mode= 'determinate')
    top_progress_bar.grid(row=5, column=2)
    
    top_end_label=tk.Label(text=" ", font=font_text)
    top_end_label.place(x=255,y = 133)
    

    folder_error_label = tk.Label(text="", font=font_text)
    folder_error_label.place(x=255,y = 160)


    
    thread_button=Checkbutton(text="no threads", variable=no_thread_check_box,font=font_text)
    thread_button.grid(row=8,column=2)
    
    
    
    thread_label= tk.Label(text="threads(1-15", font=font_text)
    thread_label.place(x=50,y=250)
    
    thread_additional=tk.Label(text="default is 15)", font=font_text)
    thread_additional.place(x=50,y=270)
    
    global thread_entry
    thread_entry=tk.Entry(window, width=5)
    thread_entry.grid(row=10,column=2,pady=2)
    
    loading_button = tk.Button(text="loading folder",font=font_text, command = lambda: get_folder_path(window,folder_error_label))
    loading_button.grid(row=6,column = 2)
    
    start_button = tk.Button(text="start",font=font_text, command =lambda: start(window,top_info_label,top_progress_bar
                                                                               ,top_start_label,top_end_label,case_id_error_label,folder_error_label))
    start_button.grid(row=7,column = 2)

    
    window.focus()
    window.mainloop()
    
            
if __name__ == "__main__":
    gui_vars.st_init()
    gui_configurtion()

